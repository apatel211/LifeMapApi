// Generated by CoffeeScript 1.8.0
(function() {
  var ConnectionFactory, HOMEDIR, LIB_COV, LIB_DIR, MockConnectionFactory, SQLClient, SQLClientPool, fs, path, should,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  SQLClient = require(path.join(LIB_DIR, 'sql-client')).SQLClient;

  SQLClientPool = require(path.join(LIB_DIR, 'sql-client-pool')).SQLClientPool;

  ConnectionFactory = require(path.join(LIB_DIR, 'connection-factory')).ConnectionFactory;

  should = require('should');

  MockConnectionFactory = (function(_super) {
    __extends(MockConnectionFactory, _super);

    function MockConnectionFactory(mock_connection, mock_error, mock_result) {
      var _base, _base1, _base2, _base3;
      this.mock_connection = mock_connection != null ? mock_connection : {};
      this.mock_error = mock_error != null ? mock_error : null;
      this.mock_result = mock_result != null ? mock_result : {};
      this.pre_process_sql = __bind(this.pre_process_sql, this);
      this.execute = __bind(this.execute, this);
      this.close_connection = __bind(this.close_connection, this);
      this.open_connection = __bind(this.open_connection, this);
      if ((_base = this.mock_connection).open_count == null) {
        _base.open_count = 0;
      }
      if ((_base1 = this.mock_connection).close_count == null) {
        _base1.close_count = 0;
      }
      if ((_base2 = this.mock_connection).executed == null) {
        _base2.executed = [];
      }
      if ((_base3 = this.mock_connection).pre_processed == null) {
        _base3.pre_processed = [];
      }
    }

    MockConnectionFactory.prototype.open_connection = function() {
      var callback, options, _i;
      options = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      this.mock_connection.open_count++;
      this.mock_connection.options = options;
      return callback(null, this.mock_connection);
    };

    MockConnectionFactory.prototype.close_connection = function(connection, callback) {
      if ((connection != null ? connection.close_count : void 0) != null) {
        connection.close_count++;
      }
      return callback(null, this.mock_connection);
    };

    MockConnectionFactory.prototype.execute = function(connection, sql, bindvars, callback) {
      if ((connection != null ? connection.close_count : void 0) != null) {
        connection.close_count++;
      }
      this.mock_connection.executed.push({
        sql: sql,
        bindvars: bindvars
      });
      return callback(this.mock_error, this.mock_result);
    };

    MockConnectionFactory.prototype.pre_process_sql = function(sql, bindvars, callback) {
      this.mock_connection.pre_processed.push({
        sql: sql,
        bindvars: bindvars
      });
      return callback(sql, bindvars);
    };

    return MockConnectionFactory;

  })(ConnectionFactory);

  describe('SQLClientPool', function() {
    it('does no pooling by default', function(done) {
      var factory, pool;
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open((function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          pool.pool.length.should.equal(0);
          return pool.borrow(function(err, first_client) {
            var first_id;
            should.not.exist(err);
            should.exist(first_client);
            first_id = first_client.id = "FIRST:" + (Date.now());
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](first_client, function(err) {
              should.not.exist(err);
              pool.pool.length.should.equal(0);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(1);
              return pool.borrow(function(err, second_client) {
                should.not.exist(err);
                should.exist(second_client);
                should.not.exist(second_client.id);
                factory.mock_connection.open_count.should.equal(2);
                factory.mock_connection.close_count.should.equal(1);
                return pool["return"](second_client, function(err) {
                  should.not.exist(err);
                  pool.pool.length.should.equal(0);
                  factory.mock_connection.open_count.should.equal(2);
                  factory.mock_connection.close_count.should.equal(2);
                  return pool.close((function(_this) {
                    return function(err) {
                      should.not.exist(err);
                      pool.pool.length.should.equal(0);
                      factory.mock_connection.open_count.should.equal(2);
                      factory.mock_connection.close_count.should.equal(2);
                      return done();
                    };
                  })(this));
                });
              });
            });
          });
        };
      })(this));
    });
    it('can lend and accept return of SQLClients', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            should.exist(client);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              return pool.close((function(_this) {
                return function(err) {
                  should.not.exist(err);
                  factory.mock_connection.close_count.should.equal(1);
                  return done();
                };
              })(this));
            });
          });
        };
      })(this));
    });
    it('can be set up for no pooling', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            should.exist(client);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(1);
              return pool.close((function(_this) {
                return function(err) {
                  should.not.exist(err);
                  factory.mock_connection.close_count.should.equal(1);
                  return done();
                };
              })(this));
            });
          });
        };
      })(this));
    });
    it('will return the same client if configuration allows', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            var id;
            should.not.exist(err);
            should.exist(client);
            id = client.id = Date.now();
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              return pool.borrow(function(err, client) {
                should.not.exist(err);
                should.exist(client);
                client.id.should.equal(id);
                factory.mock_connection.open_count.should.equal(1);
                factory.mock_connection.close_count.should.equal(0);
                return pool["return"](client, function(err) {
                  should.not.exist(err);
                  factory.mock_connection.open_count.should.equal(1);
                  return pool.close((function(_this) {
                    return function(err) {
                      should.not.exist(err);
                      factory.mock_connection.close_count.should.equal(1);
                      return done();
                    };
                  })(this));
                });
              });
            });
          });
        };
      })(this));
    });
    it('will fail when exhausted if configuration allows', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1,
        when_exhausted: 'fail'
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, first_client) {
            should.not.exist(err);
            should.exist(first_client);
            return pool.borrow(function(err, second_client) {
              should.exist(err);
              should.not.exist(second_client);
              return pool["return"](first_client, function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, third_client) {
                  should.not.exist(err);
                  should.exist(third_client);
                  return pool["return"](third_client, function(err) {
                    return pool.close((function(_this) {
                      return function(err) {
                        should.not.exist(err);
                        return done();
                      };
                    })(this));
                  });
                });
              });
            });
          });
        };
      })(this));
    });
    it('will grow when exhausted if configuration allows', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1,
        when_exhausted: 'grow'
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, first_client) {
            should.not.exist(err);
            should.exist(first_client);
            return pool.borrow(function(err, second_client) {
              should.not.exist(err);
              should.exist(second_client);
              return pool["return"](first_client, function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, third_client) {
                  should.not.exist(err);
                  should.exist(third_client);
                  return pool["return"](second_client, function(err) {
                    return pool["return"](third_client, function(err) {
                      return pool.close((function(_this) {
                        return function(err) {
                          should.not.exist(err);
                          return done();
                        };
                      })(this));
                    });
                  });
                });
              });
            });
          });
        };
      })(this));
    });
    it('will grow when exhausted by default', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, first_client) {
            should.not.exist(err);
            should.exist(first_client);
            return pool.borrow(function(err, second_client) {
              should.not.exist(err);
              should.exist(second_client);
              return pool["return"](first_client, function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, third_client) {
                  should.not.exist(err);
                  should.exist(third_client);
                  return pool["return"](second_client, function(err) {
                    return pool["return"](third_client, function(err) {
                      return pool.close((function(_this) {
                        return function(err) {
                          should.not.exist(err);
                          return done();
                        };
                      })(this));
                    });
                  });
                });
              });
            });
          });
        };
      })(this));
    });
    it('will block when exhausted if configuration allows (max_wait case)', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1,
        when_exhausted: 'block',
        max_wait: 500
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, first_client) {
            var before_block;
            should.not.exist(err);
            should.exist(first_client);
            before_block = Date.now();
            return pool.borrow(function(err, second_client) {
              should.exist(err);
              should.not.exist(second_client);
              (Date.now() - before_block).should.not.be.below(options.max_wait);
              return pool["return"](first_client, function(err) {
                should.not.exist(err);
                before_block = Date.now();
                return pool.borrow(function(err, third_client) {
                  should.not.exist(err);
                  should.exist(third_client);
                  (Date.now() - before_block).should.be.below(options.max_wait);
                  return pool["return"](third_client, function(err) {
                    return pool.close((function(_this) {
                      return function(err) {
                        should.not.exist(err);
                        return done();
                      };
                    })(this));
                  });
                });
              });
            });
          });
        };
      })(this));
    });
    it('will block when exhausted if configuration allows (returned before timeout)', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1,
        when_exhausted: 'block'
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, first_client) {
            var before_block, return_after, return_client, returned_at;
            should.not.exist(err);
            should.exist(first_client);
            before_block = Date.now();
            returned_at = null;
            return_after = 500;
            return_client = function() {
              return pool["return"](first_client, function(err) {
                should.not.exist(err);
                return returned_at = Date.now();
              });
            };
            setTimeout(return_client, return_after);
            return pool.borrow(function(err, second_client) {
              should.not.exist(err);
              should.exist(second_client);
              (Date.now() - before_block).should.not.be.below(return_after);
              (Date.now()).should.not.be.below(returned_at);
              return pool["return"](second_client, function(err) {
                should.not.exist(err);
                before_block = Date.now();
                return pool.borrow(function(err, third_client) {
                  should.not.exist(err);
                  should.exist(third_client);
                  (Date.now() - before_block).should.be.below(return_after);
                  return pool["return"](third_client, function(err) {
                    return pool.close((function(_this) {
                      return function(err) {
                        should.not.exist(err);
                        return done();
                      };
                    })(this));
                  });
                });
              });
            });
          });
        };
      })(this));
    });
    it('will reject stale clients if configuration allows', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0,
        max_active: 1,
        max_age: 250
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            should.exist(client);
            client.id = Date.now();
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(0);
              return pool.borrow(function(err, client) {
                should.not.exist(err);
                should.exist(client);
                should.exist(client.id);
                factory.mock_connection.open_count.should.equal(1);
                factory.mock_connection.close_count.should.equal(0);
                return pool["return"](client, function(err) {
                  var after_wait;
                  should.not.exist(err);
                  factory.mock_connection.open_count.should.equal(1);
                  factory.mock_connection.close_count.should.equal(0);
                  after_wait = function() {
                    return pool.borrow(function(err, client) {
                      should.not.exist(err);
                      should.exist(client);
                      should.not.exist(client.id);
                      factory.mock_connection.open_count.should.equal(2);
                      factory.mock_connection.close_count.should.equal(1);
                      return pool["return"](client, function(err) {
                        should.not.exist(err);
                        factory.mock_connection.open_count.should.equal(2);
                        factory.mock_connection.close_count.should.equal(1);
                        return pool.close(function(err) {
                          should.not.exist(err);
                          factory.mock_connection.open_count.should.equal(2);
                          factory.mock_connection.close_count.should.equal(2);
                          return done();
                        });
                      });
                    });
                  };
                  return setTimeout(after_wait, options.max_age + 50);
                });
              });
            });
          });
        };
      })(this));
    });
    it('will pre-populate min_idle clients', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 3,
        min_idle: 2
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      factory.mock_connection.open_count.should.equal(0);
      factory.mock_connection.close_count.should.equal(0);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(2);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            should.exist(client);
            factory.mock_connection.open_count.should.equal(2);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(2);
              factory.mock_connection.close_count.should.equal(0);
              return pool.close((function(_this) {
                return function(err) {
                  should.not.exist(err);
                  factory.mock_connection.open_count.should.equal(2);
                  factory.mock_connection.close_count.should.equal(2);
                  return done();
                };
              })(this));
            });
          });
        };
      })(this));
    });
    it('returning null yields error', function(done) {
      var factory, pool;
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open((function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            should.exist(client);
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](null, function(err) {
              should.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(0);
              return pool.close((function(_this) {
                return function(err) {
                  should.exist(err);
                  factory.mock_connection.open_count.should.equal(1);
                  factory.mock_connection.close_count.should.equal(0);
                  return done();
                };
              })(this));
            });
          });
        };
      })(this));
    });
    it('throws exceptions if stupid mistakes are made', function(done) {
      var err, factory, pool;
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      try {
        pool.open();
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool.open({});
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool.borrow();
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool.borrow({});
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool["return"]();
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool["return"]({}, {});
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      try {
        pool.close({});
        "Expected exception".should.not.exist;
      } catch (_error) {
        err = _error;
        (typeof err).should.not.equal('string');
      }
      return done();
    });
    it('calls-back with error when too many clients are returned', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            should.exist(client);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(0);
              return pool["return"](client, function(err) {
                should.exist(err);
                factory.mock_connection.open_count.should.equal(1);
                factory.mock_connection.close_count.should.equal(0);
                return pool.close((function(_this) {
                  return function(err) {
                    should.not.exist(err);
                    factory.mock_connection.close_count.should.equal(1);
                    return done();
                  };
                })(this));
              });
            });
          });
        };
      })(this));
    });
    it('calls-back with error when trying to use a closed pool', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.not.exist(err);
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            should.exist(client);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              factory.mock_connection.close_count.should.equal(0);
              return pool.close((function(_this) {
                return function(err) {
                  should.not.exist(err);
                  factory.mock_connection.close_count.should.equal(1);
                  return pool.borrow(function(err, client) {
                    should.exist(err);
                    return done();
                  });
                };
              })(this));
            });
          });
        };
      })(this));
    });
    it('calls-back with error if a valid client cannot be created', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      factory.open_connection = function() {
        var callback, options, _i;
        options = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        return callback(new Error("Mock Error"));
      };
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            should.exist(err);
            factory.mock_connection.open_count.should.equal(0);
            factory.mock_connection.close_count.should.equal(0);
            return pool.close((function(_this) {
              return function(err) {
                should.not.exist(err);
                return done();
              };
            })(this));
          });
        };
      })(this));
    });
    it('calls-back with error if a valid client cannot be created (min_idle case)', function(done) {
      var factory, options, pool;
      options = {
        max_idle: 5,
        min_idle: 3
      };
      factory = new MockConnectionFactory();
      factory.open_connection = function() {
        var callback, options, _i;
        options = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        return callback(new Error("Mock Error"));
      };
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.exist(err);
          return done();
        };
      })(this));
    });
    return it('will evict existing clients if reconfigured for max_idle=0', function(done) {
      var factory, options, pool;
      options = {
        max_idle: -1,
        min_idle: 0
      };
      factory = new MockConnectionFactory();
      pool = new SQLClientPool("my sql configuration", factory);
      return pool.open(options, (function(_this) {
        return function(err) {
          should.not.exist(err);
          factory.mock_connection.open_count.should.equal(0);
          factory.mock_connection.close_count.should.equal(0);
          return pool.borrow(function(err, client) {
            var id;
            should.not.exist(err);
            should.exist(client);
            id = client.id = Date.now();
            factory.mock_connection.open_count.should.equal(1);
            factory.mock_connection.close_count.should.equal(0);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              factory.mock_connection.open_count.should.equal(1);
              return pool.borrow(function(err, client) {
                should.not.exist(err);
                should.exist(client);
                client.id.should.equal(id);
                factory.mock_connection.open_count.should.equal(1);
                factory.mock_connection.close_count.should.equal(0);
                return pool["return"](client, function(err) {
                  should.not.exist(err);
                  factory.mock_connection.open_count.should.equal(1);
                  factory.mock_connection.close_count.should.equal(0);
                  return pool._config({
                    max_idle: 0
                  }, function(err) {
                    should.not.exist(err);
                    factory.mock_connection.open_count.should.equal(1);
                    factory.mock_connection.close_count.should.equal(1);
                    return pool.borrow(function(err, client) {
                      should.not.exist(err);
                      should.exist(client);
                      should.not.exist(client.id);
                      factory.mock_connection.open_count.should.equal(2);
                      factory.mock_connection.close_count.should.equal(1);
                      return pool["return"](client, function(err) {
                        should.not.exist(err);
                        factory.mock_connection.open_count.should.equal(2);
                        factory.mock_connection.close_count.should.equal(2);
                        return pool.close((function(_this) {
                          return function(err) {
                            should.not.exist(err);
                            factory.mock_connection.open_count.should.equal(2);
                            factory.mock_connection.close_count.should.equal(2);
                            return done();
                          };
                        })(this));
                      });
                    });
                  });
                });
              });
            });
          });
        };
      })(this));
    });
  });

}).call(this);
