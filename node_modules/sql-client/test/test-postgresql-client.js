// Generated by CoffeeScript 1.8.0
(function() {
  var HOMEDIR, LIB_COV, LIB_DIR, fs, path, pg, should;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  pg = require(path.join(LIB_DIR, 'postgresql-client'));

  should = require('should');

  describe('PostgreSQL', function() {
    var CONNECT_STRING, PAUSE;
    CONNECT_STRING = "postgres://sqlclient_test_user:password@localhost/sqlclient_test_db";
    PAUSE = 2;
    return it('check for database', function(done) {
      var database_available, report_no_database;
      database_available = function(callback) {
        var client;
        client = new pg.PostgreSQLClient(CONNECT_STRING);
        return client.connect(function(err) {
          var x;
          if (err != null) {
            report_no_database(err);
            x = 0;
            console.error("(Pausing for " + PAUSE + " seconds to make sure you notice the message.)");
            console.error("============================================================");
            console.error("");
            return setTimeout(callback, PAUSE * 1000);
          } else {
            return client.disconnect(function(err) {
              return callback(true);
            });
          }
        });
      };
      report_no_database = function(err) {
        console.error("");
        console.error("============================================================");
        console.error("!WARNING! COULD NOT CONNECT TO POSTGRESQL DATABASE !WARNING!");
        console.error("------------------------------------------------------------");
        console.error("");
        console.error(" The automated functional tests in:");
        console.error("     " + (path.basename(__filename)));
        console.error(" require access to a test account in a PostgeSQL database. ");
        console.error("");
        console.error(" The following error was encountered while trying to");
        console.error(" connect to the database using the connect string:");
        console.error("     " + CONNECT_STRING);
        console.error("");
        console.error(" The specific error encountered was:");
        console.error("     " + err);
        console.error(" Some unit tests will be skipped because of this error.");
        console.error("");
        console.error(" See the README file at:");
        console.error("     " + (path.join(__dirname, 'README.md')));
        console.error(" for instructions on how to set up and configure the test");
        console.error(" database in order to enable these tests.");
        console.error("");
        return console.error("------------------------------------------------------------");
      };
      return database_available(function(available) {
        if (available) {
          describe('Client', function() {
            it('can connect to the database', function(done) {
              var client;
              client = new pg.PostgreSQLClient(CONNECT_STRING);
              return client.connect(function(err) {
                if (err != null) {
                  report_no_database(err);
                }
                should.not.exist(err);
                return client.disconnect(function(err) {
                  should.not.exist(err);
                  return done();
                });
              });
            });
            it('can execute a query (straight sql)', function(done) {
              var client;
              client = new pg.PostgreSQLClient(CONNECT_STRING);
              return client.connect(function(err) {
                should.not.exist(err);
                return client.execute("SELECT 17 AS n, NOW() as dt", function(err, results) {
                  should.not.exist(err);
                  should.exist(results);
                  should.exist(results.rows);
                  results.rows.length.should.equal(1);
                  results.rows[0].n.should.equal(17);
                  results.rows[0].dt.should.be.ok;
                  return client.disconnect(function(err) {
                    should.not.exist(err);
                    return done();
                  });
                });
              });
            });
            it('can execute a query (postgresql-style ($1) bind-variables)', function(done) {
              var client;
              client = new pg.PostgreSQLClient(CONNECT_STRING);
              return client.connect(function(err) {
                should.not.exist(err);
                return client.execute("SELECT $1::INTEGER AS x", [19], function(err, results) {
                  should.not.exist(err);
                  should.exist(results);
                  should.exist(results.rows);
                  results.rows.length.should.equal(1);
                  results.rows[0].x.should.equal(19);
                  return client.disconnect(function(err) {
                    should.not.exist(err);
                    return done();
                  });
                });
              });
            });
            return it('can execute a query (?-style bind-variables)', function(done) {
              var client;
              client = new pg.PostgreSQLClient(CONNECT_STRING);
              return client.connect(function(err) {
                should.not.exist(err);
                return client.execute("SELECT ?::INTEGER AS x", [19], function(err, results) {
                  should.not.exist(err);
                  should.exist(results);
                  should.exist(results.rows);
                  results.rows.length.should.equal(1);
                  results.rows[0].x.should.equal(19);
                  return client.disconnect(function(err) {
                    should.not.exist(err);
                    return done();
                  });
                });
              });
            });
          });
          describe('ClientPool', function() {
            it('supports borrow, execute, return pattern (default config)', function(done) {
              var pool;
              pool = new pg.PostgreSQLClientPool(CONNECT_STRING);
              return pool.open(function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, client) {
                  should.not.exist(err);
                  should.exist(client);
                  return client.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [32, 18], function(err, results) {
                    should.not.exist(err);
                    should.exist(results);
                    should.exist(results.rows);
                    results.rows.length.should.equal(1);
                    results.rows[0].x.should.equal(32);
                    results.rows[0].y.should.equal(18);
                    return pool["return"](client, function(err) {
                      should.not.exist(err);
                      return pool.close(function(err) {
                        should.not.exist(err);
                        return done();
                      });
                    });
                  });
                });
              });
            });
            it('supports borrow, execute, return pattern (max_idle=5,min_idle=3)', function(done) {
              var options, pool;
              options = {
                min_idle: 3,
                max_idle: 5
              };
              pool = new pg.PostgreSQLClientPool(CONNECT_STRING);
              return pool.open(options, function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, client) {
                  should.not.exist(err);
                  should.exist(client);
                  return client.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [32, 18], function(err, results) {
                    should.not.exist(err);
                    should.exist(results);
                    should.exist(results.rows);
                    results.rows.length.should.equal(1);
                    results.rows[0].x.should.equal(32);
                    results.rows[0].y.should.equal(18);
                    return pool["return"](client, function(err) {
                      should.not.exist(err);
                      return pool.close(function(err) {
                        should.not.exist(err);
                        return done();
                      });
                    });
                  });
                });
              });
            });
            it('supports borrow, execute, borrow, execute, return, return pattern (default config)', function(done) {
              var pool;
              pool = new pg.PostgreSQLClientPool(CONNECT_STRING);
              return pool.open(function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, client1) {
                  should.not.exist(err);
                  should.exist(client1);
                  return client1.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [32, 18], function(err, results) {
                    should.not.exist(err);
                    should.exist(results);
                    should.exist(results.rows);
                    results.rows.length.should.equal(1);
                    results.rows[0].x.should.equal(32);
                    results.rows[0].y.should.equal(18);
                    return pool.borrow(function(err, client2) {
                      should.not.exist(err);
                      should.exist(client2);
                      return client2.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [1, 5], function(err, results) {
                        should.not.exist(err);
                        should.exist(results);
                        should.exist(results.rows);
                        results.rows.length.should.equal(1);
                        results.rows[0].x.should.equal(1);
                        results.rows[0].y.should.equal(5);
                        return pool["return"](client2, function(err) {
                          should.not.exist(err);
                          return pool["return"](client1, function(err) {
                            should.not.exist(err);
                            return pool.close(function(err) {
                              should.not.exist(err);
                              return done();
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
            return it('supports borrow, execute, return, borrow,  execute, return pattern (max_idle=1,min_idle=0)', function(done) {
              var options, pool;
              options = {
                max_idle: 1,
                min_idle: 0
              };
              pool = new pg.PostgreSQLClientPool(CONNECT_STRING);
              return pool.open(options, function(err) {
                should.not.exist(err);
                return pool.borrow(function(err, client1) {
                  should.not.exist(err);
                  should.exist(client1);
                  return client1.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [32, 18], function(err, results) {
                    should.not.exist(err);
                    should.exist(results);
                    should.exist(results.rows);
                    results.rows.length.should.equal(1);
                    results.rows[0].x.should.equal(32);
                    results.rows[0].y.should.equal(18);
                    return pool["return"](client1, function(err) {
                      should.not.exist(err);
                      return pool.borrow(function(err, client2) {
                        should.not.exist(err);
                        should.exist(client2);
                        return client2.execute("SELECT ?::INTEGER AS x, ?::INTEGER AS y", [1, 5], function(err, results) {
                          should.not.exist(err);
                          should.exist(results);
                          should.exist(results.rows);
                          results.rows.length.should.equal(1);
                          results.rows[0].x.should.equal(1);
                          results.rows[0].y.should.equal(5);
                          return pool["return"](client2, function(err) {
                            should.not.exist(err);
                            return pool.close(function(err) {
                              should.not.exist(err);
                              return done();
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        }
        return done();
      });
    });
  });

}).call(this);
