// Generated by CoffeeScript 1.8.0
(function() {
  var CONNECT_OPTS, HOMEDIR, LIB_COV, LIB_DIR, fs, path, should, sqlite3;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  sqlite3 = require(path.join(LIB_DIR, 'sqlite3-client'));

  should = require('should');

  CONNECT_OPTS = ':memory:';

  describe('SQLite3', function() {
    it('can connect to the database', function(done) {
      var client;
      client = new sqlite3.SQLite3Client(CONNECT_OPTS);
      return client.connect(function(err) {
        if (err != null) {
          report_no_database(err);
        }
        should.not.exist(err);
        return client.disconnect(function(err) {
          should.not.exist(err);
          return done();
        });
      });
    });
    it('can connect to the database (mode-case)', function(done) {
      var client;
      client = new sqlite3.SQLite3Client(CONNECT_OPTS, 6);
      return client.connect(function(err) {
        if (err != null) {
          report_no_database(err);
        }
        should.not.exist(err);
        return client.disconnect(function(err) {
          should.not.exist(err);
          return done();
        });
      });
    });
    it('can execute a query (straight sql)', function(done) {
      var client;
      client = new sqlite3.SQLite3Client(CONNECT_OPTS);
      return client.connect(function(err) {
        should.not.exist(err);
        return client.execute("SELECT 17 AS n", function(err, rows) {
          should.not.exist(err);
          should.exist(rows);
          rows.length.should.equal(1);
          rows[0].n.should.equal(17);
          return client.disconnect(function(err) {
            should.not.exist(err);
            return done();
          });
        });
      });
    });
    return it('can execute a query (bind-variables)', function(done) {
      var client;
      client = new sqlite3.SQLite3Client(CONNECT_OPTS);
      return client.connect(function(err) {
        should.not.exist(err);
        return client.execute("SELECT ? AS x", [19], function(err, rows) {
          should.not.exist(err);
          should.exist(rows);
          rows.length.should.equal(1);
          rows[0].x.should.equal(19);
          return client.disconnect(function(err) {
            should.not.exist(err);
            return done();
          });
        });
      });
    });
  });

  describe('ClientPool', function() {
    it('supports borrow, execute, return pattern (default config)', function(done) {
      var pool;
      pool = new sqlite3.SQLite3ClientPool(CONNECT_OPTS);
      return pool.open(function(err) {
        should.not.exist(err);
        return pool.borrow(function(err, client) {
          should.not.exist(err);
          should.exist(client);
          return client.execute("SELECT ? AS x, ? AS y", [32, 18], function(err, rows) {
            should.not.exist(err);
            should.exist(rows);
            rows.length.should.equal(1);
            rows[0].x.should.equal(32);
            rows[0].y.should.equal(18);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              return pool.close(function(err) {
                should.not.exist(err);
                return done();
              });
            });
          });
        });
      });
    });
    it('supports borrow, execute, return pattern (max_idle=5,min_idle=3)', function(done) {
      var options, pool;
      options = {
        min_idle: 3,
        max_idle: 5
      };
      pool = new sqlite3.SQLite3ClientPool(CONNECT_OPTS);
      return pool.open(options, function(err) {
        should.not.exist(err);
        return pool.borrow(function(err, client) {
          should.not.exist(err);
          should.exist(client);
          return client.execute("SELECT ? AS x, ? AS y", [32, 18], function(err, rows) {
            should.not.exist(err);
            should.exist(rows);
            rows.length.should.equal(1);
            rows[0].x.should.equal(32);
            rows[0].y.should.equal(18);
            return pool["return"](client, function(err) {
              should.not.exist(err);
              return pool.close(function(err) {
                should.not.exist(err);
                return done();
              });
            });
          });
        });
      });
    });
    it('supports borrow, execute, borrow, execute, return, return pattern (default config)', function(done) {
      var pool;
      pool = new sqlite3.SQLite3ClientPool(CONNECT_OPTS);
      return pool.open(function(err) {
        should.not.exist(err);
        return pool.borrow(function(err, client1) {
          should.not.exist(err);
          should.exist(client1);
          return client1.execute("SELECT ? AS x, ? AS y", [32, 18], function(err, rows) {
            should.not.exist(err);
            should.exist(rows);
            rows.length.should.equal(1);
            rows[0].x.should.equal(32);
            rows[0].y.should.equal(18);
            return pool.borrow(function(err, client2) {
              should.not.exist(err);
              should.exist(client2);
              return client2.execute("SELECT ? AS x, ? AS y", [1, 5], function(err, rows) {
                should.not.exist(err);
                should.exist(rows);
                rows.length.should.equal(1);
                rows[0].x.should.equal(1);
                rows[0].y.should.equal(5);
                return pool["return"](client2, function(err) {
                  should.not.exist(err);
                  return pool["return"](client1, function(err) {
                    should.not.exist(err);
                    return pool.close(function(err) {
                      should.not.exist(err);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    return it('supports borrow, execute, return, borrow,  execute, return pattern (max_idle=1,min_idle=0)', function(done) {
      var options, pool;
      options = {
        max_idle: 1,
        min_idle: 0
      };
      pool = new sqlite3.SQLite3ClientPool(CONNECT_OPTS);
      return pool.open(options, function(err) {
        should.not.exist(err);
        return pool.borrow(function(err, client1) {
          should.not.exist(err);
          should.exist(client1);
          return client1.execute("SELECT ? AS x, ? AS y", [32, 18], function(err, rows) {
            should.not.exist(err);
            should.exist(rows);
            rows.length.should.equal(1);
            rows[0].x.should.equal(32);
            rows[0].y.should.equal(18);
            return pool["return"](client1, function(err) {
              should.not.exist(err);
              return pool.borrow(function(err, client2) {
                should.not.exist(err);
                should.exist(client2);
                return client2.execute("SELECT ? AS x, ? AS y", [1, 5], function(err, rows) {
                  should.not.exist(err);
                  should.exist(rows);
                  rows.length.should.equal(1);
                  rows[0].x.should.equal(1);
                  rows[0].y.should.equal(5);
                  return pool["return"](client2, function(err) {
                    should.not.exist(err);
                    return pool.close(function(err) {
                      should.not.exist(err);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });

}).call(this);
