// Generated by CoffeeScript 1.8.0
(function() {
  var Sequencer, Util, crypto, uuid,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  uuid = require('node-uuid');

  crypto = require('crypto');

  Util = (function() {
    function Util() {}

    Util.trim = function(str) {
      return str != null ? str.replace(/(^\s+)|(\s+$)/ig, "") : void 0;
    };

    Util.isnt_blank = function(str) {
      return (str != null) && /[^\s]/.test(str);
    };

    Util.is_blank = function(str) {
      return !(Util.isnt_blank(str));
    };

    Util.blank_to_null = function(data) {
      var k, v;
      if (typeof data === 'string') {
        if (Util.is_blank(data)) {
          return null;
        }
      } else {
        for (k in data) {
          v = data[k];
          if (Util.is_blank(v)) {
            delete data[k];
            data[k] = void 0;
          }
        }
      }
      return data;
    };

    Util.truncate = function(text, width, marker) {
      var break_chars, max_shorten, max_width, short_width;
      if (marker == null) {
        marker = 'â€¦';
      }
      if ((text == null) || (text.length == null) || text.length <= width) {
        return text;
      } else {
        if (marker == null) {
          marker = '';
        }
        max_shorten = 10;
        break_chars = /\.|\!|\?|\,|\:|\-|\s|\0|\)|\(|\[|\]|\{|\}|\\|\/|\\|\<|\>|\"|\'/;
        short_width = max_width = width - marker.length;
        while (short_width > (width - max_shorten)) {
          if (break_chars.test(text.charAt(short_width))) {
            return "" + (text.substring(0, short_width)) + marker;
          } else {
            short_width--;
          }
        }
        return "" + (text.substring(0, max_width)) + marker;
      }
    };

    Util.escape_for_json = function(str) {
      if (str != null) {
        str = JSON.stringify(str);
        str = str.substring(1, str.length - 1);
        return str;
      } else {
        return null;
      }
    };

    Util.escape_for_regexp = function(str) {
      return str != null ? str.replace(/([.?*+^$[\]\/\\(){}|-])/g, "\\$1") : void 0;
    };

    Util.truthy_string = function(s) {
      return /^((T(rue)?)|(Y(es)?)|(ON)|1)$/i.test("" + s);
    };

    Util.falsey_string = function(s) {
      return /^((F(alse)?)|(No?)|(OFF)|0)$/i.test("" + s);
    };

    Util.lpad = function(value, width, pad) {
      if (value == null) {
        throw new Error("value must not be null");
      } else {
        if (Array.isArray(value)) {
          return Util.lpad_array(value, width, pad);
        } else {
          return Util.lpad_string(value, width, pad);
        }
      }
    };

    Util.lpad_array = function(value, width, pad_elt) {
      if (value == null) {
        value = [];
      }
      if (width == null) {
        width = 8;
      }
      if (pad_elt == null) {
        pad_elt = null;
      }
      while (value.length < width) {
        value = [pad_elt].concat(value);
      }
      return value;
    };

    Util.lpad_string = function(value, width, pad_char) {
      if (value == null) {
        value = "";
      }
      if (width == null) {
        width = 8;
      }
      if (pad_char == null) {
        pad_char = " ";
      }
      if (("" + pad_char).length === 0) {
        throw new Error("pad must not be empty");
      }
      value = "" + value;
      while (value.length < width) {
        value = pad_char + value;
      }
      return value;
    };

    Util.rpad = function(value, width, pad) {
      if (value == null) {
        throw new Error("value must not be null");
      } else {
        if (Array.isArray(value)) {
          return Util.rpad_array(value, width, pad);
        } else {
          return Util.rpad_string(value, width, pad);
        }
      }
    };

    Util.rpad_array = function(value, width, pad_elt) {
      if (value == null) {
        value = [];
      }
      if (width == null) {
        width = 8;
      }
      if (pad_elt == null) {
        pad_elt = null;
      }
      while (value.length < width) {
        value.push(pad_elt);
      }
      return value;
    };

    Util.rpad_string = function(value, width, pad_char) {
      if (value == null) {
        value = "";
      }
      if (width == null) {
        width = 8;
      }
      if (pad_char == null) {
        pad_char = " ";
      }
      if (("" + pad_char).length === 0) {
        throw new Error("pad must not be empty");
      } else {
        value = "" + value;
        while (value.length < width) {
          value += pad_char;
        }
        return value;
      }
    };

    Util.round_decimal = function(value, digits) {
      var factor;
      if (digits == null) {
        digits = 0;
      }
      if (value == null) {
        return null;
      } else {
        if (typeof value !== 'number') {
          if (/^\s*-?(([0-9]+(\.[0-9]+))|(\.[0-9]+))\s*$/.test("" + value)) {
            value = parseFloat(value);
          } else {
            return null;
          }
        }
        if (isNaN(value)) {
          return null;
        } else if (digits >= 0) {
          return value.toFixed(digits);
        } else {
          factor = Math.pow(10, Math.abs(digits));
          return "" + ((Math.round(value / factor)) * factor);
        }
      }
    };

    Util.is_int = function(v) {
      if (v == null) {
        return false;
      } else {
        return /^-?[1-9][0-9]*$/.test("" + v);
      }
    };

    Util.trim_trailing_null = function(a) {
      var b, v;
      a = [].concat(a);
      b = [];
      while (a.length > 0) {
        v = a.pop();
        if (v != null) {
          b.unshift(v);
        } else if (b.length > 0) {
          b.unshift(v);
        }
      }
      return b;
    };

    Util.right_shift_args = function() {
      var values;
      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Util.lpad(Util.trim_trailing_null(values), values.length, null);
    };

    Util.paginate_list = function(list, offset, limit) {
      if (offset == null) {
        offset = 0;
      }
      if (limit == null) {
        limit = 20;
      }
      return list.slice(offset, offset + limit);
    };

    Util.remove_falsey = function(map) {
      var elt, n, new_array, new_map, v, _i, _len;
      if (map == null) {
        return map;
      } else if (Array.isArray(map)) {
        new_array = [];
        for (_i = 0, _len = map.length; _i < _len; _i++) {
          elt = map[_i];
          if (elt) {
            new_array.push(elt);
          }
        }
        return new_array;
      } else if (typeof map === 'object') {
        new_map = {};
        for (n in map) {
          v = map[n];
          if (v) {
            new_map[n] = v;
          }
        }
        return new_map;
      } else if (!map) {
        return null;
      } else {
        return map;
      }
    };

    Util.merge = function() {
      var args, m, map, n, v, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      map = {};
      if (args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        m = args[_i];
        for (n in m) {
          v = m[n];
          map[n] = v;
        }
      }
      return map;
    };

    Util.shallow_clone = function(map) {
      var k, new_map, v;
      if (map != null) {
        new_map = {};
        for (k in map) {
          v = map[k];
          new_map[k] = v;
        }
        return new_map;
      } else {
        return null;
      }
    };

    Util.subset_of = function(a, b) {
      var e, _i, _len;
      if (!((a != null) && Array.isArray(a) && (b != null) && Array.isArray(b))) {
        throw new Error("Expected arrays.");
      } else {
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          e = a[_i];
          if (__indexOf.call(b, e) < 0) {
            return false;
          }
        }
        return true;
      }
    };

    Util.is_subset_of = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Util.subset_of.apply(Util, args);
    };

    Util.strict_subset_of = function(a, b) {
      return Util.subset_of(a, b) && !Util.subset_of(b, a);
    };

    Util.is_strict_subset_of = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Util.strict_subset_of.apply(Util, args);
    };

    Util.sets_are_equal = function(a, b) {
      var e, _i, _j, _len, _len1;
      if (!((a != null) && Array.isArray(a) && (b != null) && Array.isArray(b))) {
        throw new Error("Expected arrays.");
      } else {
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          e = a[_i];
          if (__indexOf.call(b, e) < 0) {
            return false;
          }
        }
        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
          e = b[_j];
          if (__indexOf.call(a, e) < 0) {
            return false;
          }
        }
        return true;
      }
    };

    Util.arrays_are_equal = function(a, b) {
      var elt, i, _i, _len;
      if (!((a != null) && Array.isArray(a) && (b != null) && Array.isArray(b))) {
        throw new Error("Expected arrays.");
      } else {
        if (a.length !== b.length) {
          return false;
        } else {
          for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
            elt = a[i];
            if (elt !== b[i]) {
              return false;
            }
          }
          return true;
        }
      }
    };

    Util.uniquify = function(array, key) {
      var clone, elt, keys, _i, _j, _len, _len1, _ref;
      clone = [];
      if (key != null) {
        keys = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          elt = array[_i];
          if (_ref = elt[key], __indexOf.call(keys, _ref) < 0) {
            clone.push(elt);
            keys.push(elt[key]);
          }
        }
      } else {
        for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
          elt = array[_j];
          console.log(elt);
          if (__indexOf.call(clone, elt) < 0) {
            clone.push(elt);
            console.log("pushed");
          }
        }
      }
      return clone;
    };

    Util.object_array_to_map = function(array, key_field, options) {
      var duplicates, elt, key, map, xform, _i, _len, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      xform = (_ref = options != null ? options.transform : void 0) != null ? _ref : (function(x) {
        return x;
      });
      duplicates = (_ref1 = options != null ? options.duplicates : void 0) != null ? _ref1 : "overwrite";
      if (duplicates !== "overwrite" && duplicates !== "stack" && duplicates !== "merge" && duplicates !== "skip") {
        throw new Error("Unrecognized value for duplicates option. Found \"" + duplicates + "\". Expected \"overwrite\", \"stack\", \"skip\", \"merge\" or null.");
      }
      map = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        elt = array[_i];
        key = xform(elt[key_field]);
        if ((map[key] != null) && duplicates !== "overwrite") {
          if (duplicates === 'stack') {
            if (Array.isArray(map[key])) {
              map[key].push(elt);
            } else {
              map[key] = [map[key], elt];
            }
          } else if (duplicates === 'merge') {
            map[key] = Util.merge(map[key], elt);
          }
        } else {
          map[key] = elt;
        }
      }
      return map;
    };

    Util.hex_to_rgb_triplet = function(hex) {
      var result;
      result = /^\s*#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})\s*$/i.exec(hex);
      if (result != null) {
        return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
      } else {
        return null;
      }
    };

    Util.hex_to_rgb_string = function(hex) {
      var b, g, r, _ref, _ref1;
      _ref1 = (_ref = Util.hex_to_rgb_triplet(hex)) != null ? _ref : [null, null, null], r = _ref1[0], g = _ref1[1], b = _ref1[2];
      if ((r != null) && (g != null) && (b != null)) {
        return "rgb(" + r + "," + g + "," + b + ")";
      } else {
        return null;
      }
    };

    Util.rgb_string_to_triplet = function(rgb) {
      var b, g, r, result;
      result = /^\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*$/i.exec(rgb);
      if (result != null) {
        r = parseInt(result[1]);
        g = parseInt(result[2]);
        b = parseInt(result[3]);
        return [r, g, b];
      } else {
        return null;
      }
    };

    Util.rgb_to_hex = function(r, g, b) {
      var i2h, _ref, _ref1;
      if (typeof r === 'string' && (g == null) && (b == null)) {
        _ref1 = (_ref = Util.rgb_string_to_triplet(r)) != null ? _ref : [null, null, null], r = _ref1[0], g = _ref1[1], b = _ref1[2];
      }
      if (!((r != null) && (g != null) && (b != null))) {
        return null;
      } else {
        i2h = function(i) {
          var h;
          h = i.toString(16);
          if (h.length === 1) {
            return "0" + h;
          } else {
            return h;
          }
        };
        return "#" + (i2h(r)) + (i2h(g)) + (i2h(b));
      }
    };

    Util.random_bytes = function(count, enc) {
      var bytes, _ref;
      if (count == null) {
        count = 32;
      }
      if (enc == null) {
        enc = 'hex';
      }
      if (typeof count === 'string') {
        if (typeof enc === 'number') {
          _ref = [enc, count], count = _ref[0], enc = _ref[1];
        } else {
          enc = count;
          count = 32;
        }
      }
      bytes = crypto.randomBytes(count);
      if (/buffer/i.test(enc)) {
        return bytes;
      } else {
        return bytes.toString(enc);
      }
    };

    Util.random_hex = function(count) {
      if (count == null) {
        count = 32;
      }
      return Util._random_digits(count, 16);
    };

    Util.random_alphanumeric = function(count) {
      if (count == null) {
        count = 32;
      }
      return Util._random_digits(count, 36);
    };

    Util._random_digits = function(count, base) {
      var str;
      if (count == null) {
        count = 32;
      }
      str = "";
      while (str.length < count) {
        str += Math.random().toString(base).substring(2);
      }
      if (str.length > count) {
        str = str.substring(0, count);
      }
      return str;
    };

    Util.slow_equals = function(a, b) {
      var delta_count, i, same_count, _i, _ref, _ref1;
      same_count = delta_count = 0;
      if (b.length > a.length) {
        _ref = [b, a], a = _ref[0], b = _ref[1];
      }
      for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        if (a[i] !== b[i]) {
          delta_count += 1;
        } else {
          same_count += 1;
        }
      }
      if (delta_count === 0 && a.length === b.length) {
        return [true, same_count, delta_count];
      } else {
        return [false, same_count, delta_count];
      }
    };

    Util.validate_hashed_password = function(expected_digest, password, salt, pepper, hash_type) {
      var digest, _ref;
      _ref = Util.hash_password(password, salt, pepper, hash_type), salt = _ref[0], digest = _ref[1];
      password = void 0;
      return Util.slow_equals(expected_digest, digest)[0];
    };

    Util.hash_password = function(password, salt, pepper, hash_type) {
      var digest, hash;
      if (typeof password === 'object') {
        hash_type = password.hash_type;
        pepper = password.pepper;
        salt = password.salt;
        password = password.password;
      }
      if (hash_type == null) {
        hash_type = 'sha512';
      }
      if (salt == null) {
        salt = 64;
      }
      if ((password != null) && !Buffer.isBuffer(password)) {
        password = new Buffer(password);
      }
      if ((pepper != null) && !Buffer.isBuffer(pepper)) {
        pepper = new Buffer(pepper);
      }
      if (typeof salt === 'number') {
        salt = Util.random_bytes(salt, 'buffer');
      } else if (!Buffer.isBuffer(salt)) {
        salt = new Buffer(salt);
      }
      if (password == null) {
        throw new Error("password parameter is required");
      } else {
        hash = crypto.createHash(hash_type);
        hash.update(salt);
        if (pepper != null) {
          hash.update(pepper);
        }
        hash.update(password);
        password = void 0;
        digest = hash.digest();
        return [salt, digest];
      }
    };

    Util.compare = function(a, b) {
      if ((a != null) && (b != null)) {
        return (a > b ? 1 : (a < b ? -1 : 0));
      } else if ((a != null) && (b == null)) {
        return 1;
      } else if ((b != null) && (a == null)) {
        return -1;
      } else {
        return 0;
      }
    };

    Util.case_insensitive_compare = function(a, b) {
      var A, B, result;
      if ((a != null ? a.toUpperCase : void 0) != null) {
        A = a.toUpperCase();
      } else {
        A = a;
      }
      if ((b != null ? b.toUpperCase : void 0) != null) {
        B = b.toUpperCase();
      } else {
        B = b;
      }
      result = Util.compare(A, B);
      if (result === 0) {
        result = Util.compare(a, b);
      }
      return result;
    };

    Util.field_comparator = function(field, ignore_case) {
      if (ignore_case == null) {
        ignore_case = false;
      }
      return Util.path_comparator([field], ignore_case);
    };

    Util.path_comparator = function(path, ignore_case) {
      if (ignore_case == null) {
        ignore_case = false;
      }
      return function(a, b) {
        var A, B, f, fn, _i, _len;
        fn = ignore_case ? 'case_insensitive_compare' : 'compare';
        A = a;
        B = b;
        for (_i = 0, _len = path.length; _i < _len; _i++) {
          f = path[_i];
          A = A != null ? A[f] : void 0;
          B = B != null ? B[f] : void 0;
          if (!((A != null) && (B != null))) {
            return Util[fn](A, B);
          }
        }
        return Util[fn](A, B);
      };
    };

    Util.desc_comparator = function(c) {
      return function(a, b) {
        return c(b, a);
      };
    };

    Util.descending_comparator = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Util.desc_comparator.apply(Util, args);
    };

    Util.composite_comparator = function(list) {
      return function(a, b) {
        var c, r, _i, _len;
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          c = list[_i];
          r = c(a, b);
          if (r !== 0) {
            return r;
          }
        }
        return 0;
      };
    };

    Util.remote_ip = function(req) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      return (_ref = (_ref1 = (_ref2 = (_ref3 = req != null ? typeof req.get === "function" ? req.get('x-forwarded-for') : void 0 : void 0) != null ? _ref3 : req != null ? (_ref4 = req.headers) != null ? _ref4['x-forwarded-for'] : void 0 : void 0) != null ? _ref2 : req != null ? (_ref5 = req.connection) != null ? _ref5.remoteAddress : void 0 : void 0) != null ? _ref1 : req != null ? (_ref6 = req.socket) != null ? _ref6.remoteAddress : void 0 : void 0) != null ? _ref : req != null ? (_ref7 = req.connection) != null ? (_ref8 = _ref7.socket) != null ? _ref8.remoteAddress : void 0 : void 0 : void 0;
    };

    Util.handle_error = function(err, callback, throw_when_no_callback) {
      if (throw_when_no_callback == null) {
        throw_when_no_callback = true;
      }
      if (err != null) {
        if (callback != null) {
          callback(err);
          return true;
        } else if (throw_when_no_callback) {
          throw err;
        } else {
          return console.error("ERROR", err);
        }
      } else {
        return false;
      }
    };

    Util.uuid = function(v, generate) {
      if (generate == null) {
        generate = false;
      }
      if (v == null) {
        if (generate) {
          v = Util.uuid(uuid.v1());
        } else {
          return null;
        }
      } else if (v.replace == null) {
        throw new Error("Expected string but found " + (typeof v), v);
      } else if (!/^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i.test(v)) {
        throw new Error("Encountered invalid UUID format " + v + ".");
      }
      return v.replace(/-/g, '').toLowerCase();
    };

    Util.pad_uuid = function(v, generate) {
      if (generate == null) {
        generate = false;
      }
      v = Util.uuid(v, generate);
      if (v != null) {
        return v.substring(0, 8) + "-" + v.substring(8, 12) + "-" + v.substring(12, 16) + "-" + v.substring(16, 20) + "-" + v.substring(20);
      } else {
        return null;
      }
    };

    Util.b64e = function(buf, output_encoding) {
      if (output_encoding == null) {
        output_encoding = 'utf8';
      }
      if (buf == null) {
        return null;
      } else {
        if (!(buf instanceof Buffer)) {
          buf = new Buffer(buf.toString(), output_encoding);
        }
        return buf.toString('base64');
      }
    };

    Util.b64d = function(buf, output_encoding) {
      if (output_encoding == null) {
        output_encoding = 'utf8';
      }
      if (buf == null) {
        return null;
      } else {
        if (!(buf instanceof Buffer)) {
          buf = new Buffer(buf.toString(), 'base64');
        }
        return buf.toString(output_encoding);
      }
    };

    Util.for_async = function(initialize, condition, action, increment, whendone) {
      var looper;
      looper = function() {
        if (condition()) {
          return action(function() {
            increment();
            return looper();
          });
        } else {
          if (whendone != null) {
            return whendone();
          }
        }
      };
      initialize();
      return looper();
    };

    Util.for_each_async = function(list, action, whendone) {
      var act, cond, i, incr, init, m;
      i = m = null;
      init = function() {
        return i = 0;
      };
      cond = function() {
        return i < list.length;
      };
      incr = function() {
        return i += 1;
      };
      act = function(next) {
        return action(list[i], i, list, next);
      };
      return Util.for_async(init, cond, act, incr, whendone);
    };

    Util.procedure = function() {
      return new Sequencer();
    };

    return Util;

  })();

  Sequencer = (function() {
    function Sequencer() {
      this.run = __bind(this.run, this);
      this["finally"] = __bind(this["finally"], this);
      this.last = __bind(this.last, this);
      this.then = __bind(this.then, this);
      this.next = __bind(this.next, this);
      this.first = __bind(this.first, this);
      this.list = [];
    }

    Sequencer.prototype.first = function(step) {
      this.list = [];
      this.list.push(step);
      return this;
    };

    Sequencer.prototype.next = function(step) {
      this.list.push(step);
      return this;
    };

    Sequencer.prototype.then = function(step) {
      return this.next(step);
    };

    Sequencer.prototype.last = function(step, callback) {
      this.next(step);
      this.run(callback);
      return this;
    };

    Sequencer.prototype["finally"] = function(step, callback) {
      return this.last(step, callback);
    };

    Sequencer.prototype.run = function() {
      var action, args, callback, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      action = (function(_this) {
        return function(step, index, list, next) {
          return step.apply(null, __slice.call(args).concat([function() {
            var new_args;
            new_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            args = new_args;
            return next();
          }]));
        };
      })(this);
      Util.for_each_async(this.list, action, (function(_this) {
        return function() {
          return typeof callback === "function" ? callback.apply(null, args) : void 0;
        };
      })(this));
      return this;
    };

    return Sequencer;

  })();

  exports.Util = Util;

  exports.Sequencer = Sequencer;

}).call(this);
